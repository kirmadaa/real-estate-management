name: TaskApi - Docker Build, Push, and Security Scan

on:
  workflow_dispatch:
  push: # Trigger on push to main/master for automated fixes
    branches:
      - main
      - master

env:
  IMAGE_NAME: kirmadadaa/taskapi-frontend # Ensures correct formatting
  # Define the paths for your Dockerfile and application root here
  DEFAULT_APP_DOCKERFILE_PATH: frontend/Dockerfile
  DEFAULT_APP_ROOT_DIRECTORY: frontend/

jobs:
  set_env:
    name: üõ† Set Variables
    runs-on: ubuntu-latest
    outputs:
      image_name: ${{ steps.setvars.outputs.image_name }}
      image_tag: ${{ steps.setvars.outputs.image_tag }}
      checkout_branch: ${{ steps.setvars.outputs.checkout_branch }}
      run_id: ${{ github.run_id }} # Pass run ID for artifact download
      app_dockerfile_path: ${{ steps.setvars.outputs.app_dockerfile_path }}
      app_root_directory: ${{ steps.setvars.outputs.app_root_directory }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Set environment variables
        id: setvars
        run: |
          echo "image_name=${{ env.IMAGE_NAME }}" >> $GITHUB_OUTPUT
          echo "image_tag=${GITHUB_SHA::8}" >> $GITHUB_OUTPUT
          echo "checkout_branch=${GITHUB_REF#refs/heads/}" >> $GITHUB_OUTPUT
          echo "run_id=${GITHUB_RUN_ID}" >> $GITHUB_OUTPUT # Capture run ID
          echo "app_dockerfile_path=${{ env.DEFAULT_APP_DOCKERFILE_PATH }}" >> $GITHUB_OUTPUT
          echo "app_root_directory=${{ env.DEFAULT_APP_ROOT_DIRECTORY }}" >> $GITHUB_OUTPUT

  docker_build_push:
    name: üê≥ Build and Push Docker Image
    needs: set_env
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver: docker-container
          buildkitd-flags: --debug

      - name: Log in to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_PASSWORD }}

      - name: Verify Docker Hub login
        run: |
          echo "Logged in as:"
          docker info | grep Username
          echo "Trying to push to: ${{ env.IMAGE_NAME }}"

      - name: Build and Push Docker Image
        id: push
        uses: docker/build-push-action@v5
        with:
          context: ${{ needs.set_env.outputs.app_root_directory }}
          file: ${{ needs.set_env.outputs.app_dockerfile_path }}
          push: true
          tags: |
            ${{ env.IMAGE_NAME }}:${{ needs.set_env.outputs.image_tag }}
            ${{ env.IMAGE_NAME }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            BUILDKIT_PROGRESS=plain
        env:
          DOCKER_BUILDKIT: 1

      - name: Verify Push Success
        run: |
          echo "Pushed image: ${{ env.IMAGE_NAME }}:${{ needs.set_env.outputs.image_tag }}"
          docker pull ${{ env.IMAGE_NAME }}:${{ needs.set_env.outputs.image_tag }} || echo "Pull test failed"

  trivy_scan:
    name: üîç Trivy Security Scan (Initial)
    needs: [set_env, docker_build_push]
    runs-on: ubuntu-latest
    outputs:
      vulnerabilities_found: ${{ steps.generate_json_report.outputs.found }}
    steps:
      - name: Set image variables
        id: vars
        run: |
          echo "IMAGE_NAME=${{ needs.set_env.outputs.image_name }}" >> $GITHUB_ENV
          echo "IMAGE_TAG=${{ needs.set_env.outputs.image_tag }}" >> $GITHUB_ENV
          echo "Set IMAGE_NAME=${{ needs.set_env.outputs.image_name }}"
          echo "Set IMAGE_TAG=${{ needs.set_env.outputs.image_tag }}"

      - name: Install Trivy
        run: |
          curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sudo sh -s -- -b /usr/local/bin
          trivy --version

      - name: Verify variables
        run: |
          echo "Image to scan: ${IMAGE_NAME}:${IMAGE_TAG}"
          if [ -z "${IMAGE_NAME}" ] || [ -z "${IMAGE_TAG}" ]; then
            echo "ERROR: Image name or tag is empty!"
            exit 1
          fi

      - name: Pull Docker image
        run: |
          docker pull ${IMAGE_NAME}:${IMAGE_TAG} || (echo "ERROR: Failed to pull image"; exit 1)

      - name: Scan with Trivy (Table format for logs)
        run: |
          trivy image \
            --scanners vuln \
            --format table \
            --exit-code 0 \
            --timeout 10m \
            "${IMAGE_NAME}:${IMAGE_TAG}"

      - name: Generate JSON report
        id: generate_json_report
        run: |
          trivy image \
            --scanners vuln \
            --format json \
            --output trivy-report.json \
            "${IMAGE_NAME}:${IMAGE_TAG}"

          if jq -e '.[] | select(.Vulnerabilities != null and .Vulnerabilities | length > 0)' trivy-report.json > /dev/null; then
            echo "Vulnerabilities found!"
            echo "found=true" >> $GITHUB_OUTPUT
          else
            echo "No vulnerabilities found in this scan."
            echo "found=false" >> $GITHUB_OUTPUT
          fi

      - name: Upload report
        uses: actions/upload-artifact@v4
        with:
          name: trivy-security-report
          path: trivy-report.json

  remediation:
    name: üîß Automated Remediation
    needs: [set_env, trivy_scan]
    if: needs.trivy_scan.outputs.vulnerabilities_found == 'true' # Only run if vulns found
    runs-on: ubuntu-latest
    env:
      BRANCH: ${{ needs.set_env.outputs.checkout_branch }}
      RUN_ID: ${{ needs.set_env.outputs.run_id }}
      IMAGE_NAME: ${{ needs.set_env.outputs.image_name }}
      IMAGE_TAG: ${{ needs.set_env.outputs.image_tag }}
      # --- Pass these dynamic paths as ENVIRONMENT VARIABLES for the script ---
      TRIVY_REPORT_PATH: trivy-report.json # This file is downloaded to current directory
      DOCKERFILE_PATH: ${{ needs.set_env.outputs.app_dockerfile_path }}
      APP_ROOT_DIR: ${{ needs.set_env.outputs.app_root_directory }}
      # --- END FIX ---
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ env.BRANCH }}
          # The auto-commit action needs push permissions
          token: ${{ secrets.GITHUB_TOKEN }} 

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Install JQ for JSON parsing (for workflow steps, script uses python json)
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Install Trivy (for re-validation within script)
        run: |
          curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sudo sh -s -- -b /usr/local/bin
          trivy --version

      - name: Install npm (if needed for Node.js projects)
        run: |
          # Check if package.json exists in the specified APP_ROOT_DIR
          if [ -f "${{ env.APP_ROOT_DIR }}/package.json" ]; then
            echo "package.json detected. Installing npm."
            sudo apt-get install -y npm
          else
            echo "package.json not detected in ${{ env.APP_ROOT_DIR }}. Skipping npm installation."
          fi

      - name: Set up Go (if needed for Go projects)
        run: |
          if [ -f "${{ env.APP_ROOT_DIR }}/go.mod" ]; then
            echo "go.mod detected. Setting up Go."
            curl -LO https://go.dev/dl/go1.22.4.linux-amd64.tar.gz
            sudo tar -C /usr/local -xzf go1.22.4.linux-amd64.tar.gz
            echo "/usr/local/go/bin" >> $GITHUB_PATH
            go version
          else
            echo "go.mod not detected in ${{ env.APP_ROOT_DIR }}. Skipping Go installation."
          fi

      - name: Set up Ruby (if needed for Ruby projects)
        run: |
          if [ -f "${{ env.APP_ROOT_DIR }}/Gemfile" ] || [ -f "${{ env.APP_ROOT_DIR }}/Gemfile.lock" ]; then
            echo "Gemfile detected. Setting up Ruby."
            sudo apt-get install -y ruby-full
            gem install bundler
            ruby --version
            bundle --version
          else
            echo "Gemfile not detected in ${{ env.APP_ROOT_DIR }}. Skipping Ruby installation."
          fi


      - name: Download Trivy report artifact
        uses: actions/download-artifact@v4
        with:
          name: trivy-security-report
          path: . # Downloads trivy-report.json to the current directory

      - name: Make remediation script executable
        # Assuming the script is at .github/scripts/remediat.py
        run: chmod +x .github/scripts/remediat.py

      - name: Run remediation script
        id: run_remediation
        # Let the script control its exit code. If it exits with 1, this step will fail.
        # This is desired to fail the workflow if remediation was completely unsuccessful.
        run: |
          # The Python script will read its inputs from environment variables
          # as configured in the 'env:' block of this job.
          python .github/scripts/remediat.py

      - name: Check for changes after remediation script
        id: git_status_check
        run: |
          # Temporarily configure git to detect changes
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          git add .
          # Check for any staged changes. If there are, git diff --cached --quiet will exit with 1.
          # If no changes, it exits with 0.
          if ! git diff --cached --quiet; then
            echo "changes_made=true" >> $GITHUB_OUTPUT
            echo "Repository changes detected after remediation script execution."
          else
            echo "changes_made=false" >> $GITHUB_OUTPUT
            echo "No changes detected after remediation script execution."
          fi
          # Do not clean up staged changes; the auto-commit action will handle it.

      - name: Commit & push fixes (if changes detected by script)
        if: steps.git_status_check.outputs.changes_made == 'true'
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "feat(security): Automated vulnerability remediation by Trivy report"
          branch: ${{ env.BRANCH }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # Required for pushing

      - name: Re-scan to Validate Fixes (if changes were committed)
        id: validation_scan # Give this step an ID to reference its outputs
        if: steps.git_status_check.outputs.changes_made == 'true'
        run: |
          echo "Running final Trivy re-scan on the remediated image for validation."
          # The remediated image name is generated by the Python script using a timestamp,
          # so we need to derive it or assume a pattern.
          # For robust validation, the python script should push the remediated image
          # to a well-known tag/name, or output its name to a file,
          # or the workflow should pass it back.
          # For simplicity, we'll try to re-use the python script's logic to form the tag.
          # A better approach would be to have the Python script output the new image name
          # to a file, which the workflow then reads.
          
          # Deducing the remediated image name from Python script's logic
          # This relies on the convention: IMAGE_NAME:remediated-TIMESTAMP
          # We'll just build it directly here using the current timestamp for illustration.
          # In a true scenario, the remediation script would push the image and output its tag.
          # For now, let's assume the script rebuilt and tagged the image as `IMAGE_NAME:remediated-current_timestamp`
          # This assumes `build_docker_image` within the python script also pushes.
          # Or, ideally, the python script's build_docker_image just builds locally,
          # and the workflow explicitly pushes it here if validation passes.
          # For simplicity of this example, we assume `remediat.py` handled the build.
          # To truly validate, we need to re-pull the *newly committed* code, rebuild, and re-scan.
          # The `remediat.py` actually performs the rebuild and re-scan internally,
          # and leaves a `trivy-remediated-scan-report.json`.
          # So we just need to read its output.

          # This step now focuses on parsing the report generated by the remediation script
          if [ -f "${{ env.TRIVY_REPORT_PATH }}" ]; then
            echo "Analyzing the remediation script's re-scan report: ${{ env.TRIVY_REPORT_PATH }}"
            # We need the report generated by the python script (e.g., trivy-remediated-scan-report.json)
            # which is written to the same directory as the initial report.
            REMEDIATED_REPORT_PATH=$(dirname "${{ env.TRIVY_REPORT_PATH }}")/trivy-remediated-scan-report.json

            if [ -f "$REMEDIATED_REPORT_PATH" ]; then
                if jq -e '.[] | select(.Vulnerabilities != null and .Vulnerabilities | length > 0)' "$REMEDIATED_REPORT_PATH" > /dev/null; then
                  echo "Vulnerabilities still present after remediation. Manual review needed."
                  echo "remediation_validation=failure" >> $GITHUB_OUTPUT
                else
                  echo "Image is clean after remediation. Great success!"
                  echo "remediation_validation=success" >> $GITHUB_OUTPUT
                fi
            else
                echo "Remediated scan report '$REMEDIATED_REPORT_PATH' not found. Cannot validate fixes."
                echo "remediation_validation=unknown" >> $GITHUB_OUTPUT
            fi
          else
            echo "Initial Trivy report '${{ env.TRIVY_REPORT_PATH }}' not found. Cannot proceed with validation."
            echo "remediation_validation=unknown" >> $GITHUB_OUTPUT
          fi

      - name: Upload remediated report artifact (if generated)
        if: steps.git_status_check.outputs.changes_made == 'true' && success() # Only upload if changes were made and previous steps succeeded
        uses: actions/upload-artifact@v4
        with:
          name: trivy-remediated-security-report
          path: trivy-remediated-scan-report.json # Path written by remediat.py

      # - name: Notify Slack (Remediation Status)
      #   uses: rtCamp/action-slack-notify@v2
      #   env:
      #     SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK_URL }}
      #     SLACK_CHANNEL: '#devsecops-alerts' # Customize your Slack channel
      #     SLACK_USERNAME: 'Vulnerability Remediation Bot'
      #     SLACK_ICON_EMOJI: ':robot_face:'
      #     SLACK_MESSAGE: |
      #       *Automated Vulnerability Remediation Attempt Result*
      #       Repository: `${{ github.repository }}`
      #       Branch: `${{ env.BRANCH }}`
      #       Workflow Run: <https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}|#${{ github.run_id }}>
            
      #       ${{ steps.git_status_check.outputs.changes_made == 'true' && '‚úÖ Fixes Applied & Committed!' || '‚ÑπÔ∏è No fixes applied or no changes needed.' }}
      #       ${{ steps.git_status_check.outputs.changes_made == 'true' && format('Validation Scan: {0}', steps.validation_scan.outputs.remediation_validation) || '' }}
            
      #       ${{ success() && 'üü¢ Workflow completed successfully.' || 'üî¥ Workflow failed or had issues.' }}
      #       ${{ failure() && 'üö® Manual intervention required.' || '' }}
        # if: always() # Always run notification

  # Uncomment and modify these deployment jobs as needed
  # Deployment should only happen if initial scan was clean OR remediation successfully cleaned the image.
  # This requires the remediation job to explicitly output success/failure for validation.
  # The `remediation` job now sets `steps.validation_scan.outputs.remediation_validation` to 'success' or 'failure'.
  # ccli_hydra_e1_deployment:
  #   name: üöÄüü° Deploy image to E1 Hydra
  #   needs: [set_env, docker_build_push, trivy_scan, remediation]
  #   if: |
  #     (needs.trivy_scan.outputs.vulnerabilities_found == 'false') || 
  #     (needs.remediation.outputs.remediation_validation == 'success')
    # If remediation occurred and was successful, use the remediated image tag.
    # Otherwise, use the original image tag.
    # This requires the remediation step to output the new image tag.
    # For now, let's assume the build/push job pushed the original image,
    # and the remediation script pushes the remediated image with a distinct tag.
    # This part needs more careful design to pass the *actual* deployable image tag.
    # For simplicity, if remediation was successful, we'd deploy the *latest* remediated image.
    # This example assumes the deployment workflow pulls `image_name:latest` or similar.
    # Ideally, the `remediation` job would push `image_name:remediated-latest` and `docker_build_push` pushes `image_name:original-latest`.
    # And this job selects the appropriate tag.

    # This part depends heavily on your deployment system.
    # If your deployment system supports specifying the image by sha256 or a unique tag,
    # the remediation job needs to output the new image tag.
    # For now, this is a placeholder.
    # uses: amex-eng/ace-platform-reusable-workflow/.github/workflows/deploy_to_hydra_ccli_validate.yml@main
    # with:
    #   image_name_ccli: artifactory.aexp.com/dockerproxy/${{ needs.set_env.outputs.image_name }}
    #   sha256: ${{ needs.ace-build.outputs.pushed_image }} # This needs to be the SHA of the *remediated* image if remediation happened.
    #   regions: US
    #   env: "E1"
    #   project: ${{ vars.PROJECT }}
    #   service: ${{ vars.SERVICE }}
    #   image_time_stamp: ${{ needs.set_env.outputs.image_tag }} # This needs to be the *remediated* tag
    # secrets:
    #   SE_USERNAME: ${{ secrets.SE_USERNAME }}
    #   SE_PASSWORD: ${{ secrets.SE_PASSWORD }}
    #   ARTIFACTORY_USERNAME: ${{ secrets.ARTIFACTORY_USERNAME }}
    #   ARTIFACTORY_PASSWORD: ${{ secrets.ARTIFACTORY_PASSWORD }}
