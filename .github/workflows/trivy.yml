name: TaskApi - Docker Build, Push, and Security Scan

on:
  workflow_dispatch:
  push: # Trigger on push to main/master for automated fixes
    branches:
      - main
      - master

env:
  IMAGE_NAME: kirmadadaa/taskapi-frontend # Ensures correct formatting
  # Define the paths for your Dockerfile and application root here
  # This makes the workflow more configurable for different projects/modules
  # These are now defaults that will be passed as outputs from set_env
  DEFAULT_APP_DOCKERFILE_PATH: frontend/Dockerfile
  DEFAULT_APP_ROOT_DIRECTORY: frontend/

jobs:
  set_env:
    name: ðŸ›  Set Variables
    runs-on: ubuntu-latest
    outputs:
      image_name: ${{ steps.setvars.outputs.image_name }}
      image_tag: ${{ steps.setvars.outputs.image_tag }}
      checkout_branch: ${{ steps.setvars.outputs.checkout_branch }}
      run_id: ${{ github.run_id }} # Pass run ID for artifact download
      app_dockerfile_path: ${{ steps.setvars.outputs.app_dockerfile_path }}
      app_root_directory: ${{ steps.setvars.outputs.app_root_directory }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Set environment variables
        id: setvars
        run: |
          echo "image_name=${{ env.IMAGE_NAME }}" >> $GITHUB_OUTPUT
          echo "image_tag=${GITHUB_SHA::8}" >> $GITHUB_OUTPUT
          echo "checkout_branch=${GITHUB_REF#refs/heads/}" >> $GITHUB_OUTPUT
          echo "run_id=${GITHUB_RUN_ID}" >> $GITHUB_OUTPUT # Capture run ID
          echo "app_dockerfile_path=${{ env.DEFAULT_APP_DOCKERFILE_PATH }}" >> $GITHUB_OUTPUT
          echo "app_root_directory=${{ env.DEFAULT_APP_ROOT_DIRECTORY }}" >> $GITHUB_OUTPUT

  docker_build_push:
    name: ðŸ³ Build and Push Docker Image
    needs: set_env
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver: docker-container
          buildkitd-flags: --debug

      - name: Log in to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_PASSWORD }}

      - name: Verify Docker Hub login
        run: |
          echo "Logged in as:"
          docker info | grep Username
          echo "Trying to push to: ${{ env.IMAGE_NAME }}"

      - name: Build and Push Docker Image
        id: push
        uses: docker/build-push-action@v5
        with:
          context: ${{ needs.set_env.outputs.app_root_directory }}
          file: ${{ needs.set_env.outputs.app_dockerfile_path }}
          push: true
          tags: |
            ${{ env.IMAGE_NAME }}:${{ needs.set_env.outputs.image_tag }}
            ${{ env.IMAGE_NAME }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            BUILDKIT_PROGRESS=plain
        env:
          DOCKER_BUILDKIT: 1

      - name: Verify Push Success
        run: |
          echo "Pushed image: ${{ env.IMAGE_NAME }}:${{ needs.set_env.outputs.image_tag }}"
          docker pull ${{ env.IMAGE_NAME }}:${{ needs.set_env.outputs.image_tag }} || echo "Pull test failed"

  trivy_scan:
    name: ðŸ” Trivy Security Scan
    needs: [set_env, docker_build_push]
    runs-on: ubuntu-latest
    outputs:
      vulnerabilities_found: ${{ steps.generate_json_report.outputs.found }}
    steps:
      - name: Set image variables
        id: vars
        run: |
          echo "IMAGE_NAME=${{ needs.set_env.outputs.image_name }}" >> $GITHUB_ENV
          echo "IMAGE_TAG=${{ needs.set_env.outputs.image_tag }}" >> $GITHUB_ENV
          echo "Set IMAGE_NAME=${{ needs.set_env.outputs.image_name }}"
          echo "Set IMAGE_TAG=${{ needs.set_env.outputs.image_tag }}"

      - name: Install Trivy
        run: |
          curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sudo sh -s -- -b /usr/local/bin
          trivy --version

      - name: Verify variables
        run: |
          echo "Image to scan: ${IMAGE_NAME}:${IMAGE_TAG}"
          if [ -z "${IMAGE_NAME}" ] || [ -z "${IMAGE_TAG}" ]; then
            echo "ERROR: Image name or tag is empty!"
            exit 1
          fi

      - name: Pull Docker image
        run: |
          docker pull ${IMAGE_NAME}:${IMAGE_TAG} || (echo "ERROR: Failed to pull image"; exit 1)

      - name: Scan with Trivy (Table format for logs)
        run: |
          trivy image \
            --scanners vuln \
            --format table \
            --exit-code 0 \
            --timeout 10m \
            "${IMAGE_NAME}:${IMAGE_TAG}"

      - name: Generate JSON report
        id: generate_json_report
        run: |
          trivy image \
            --scanners vuln \
            --format json \
            --output trivy-report.json \
            "${IMAGE_NAME}:${IMAGE_TAG}"

          if jq -e '.[] | select(.Vulnerabilities != null and .Vulnerabilities | length > 0)' trivy-report.json > /dev/null; then
            echo "Vulnerabilities found!"
            echo "found=true" >> $GITHUB_OUTPUT
          else
            echo "No vulnerabilities found in this scan."
            echo "found=false" >> $GITHUB_OUTPUT
          fi

      - name: Upload report
        uses: actions/upload-artifact@v4
        with:
          name: trivy-security-report
          path: trivy-report.json

  remediation:
    name: ðŸ”§ Automated Remediation
    needs: [set_env, trivy_scan]
    # if: needs.trivy_scan.outputs.vulnerabilities_found == 'true' # Uncomment to only run if vulns found
    runs-on: ubuntu-latest
    env:
      BRANCH: ${{ needs.set_env.outputs.checkout_branch }}
      RUN_ID: ${{ needs.set_env.outputs.run_id }}
      IMAGE_NAME: ${{ needs.set_env.outputs.image_name }}
      IMAGE_TAG: ${{ needs.set_env.outputs.image_tag }}
      # --- FIX: Pass these dynamic paths as ENVIRONMENT VARIABLES for the script ---
      TRIVY_REPORT_PATH: trivy-report.json # This file is downloaded to current directory
      DOCKERFILE_PATH: ${{ needs.set_env.outputs.app_dockerfile_path }}
      APP_ROOT_DIR: ${{ needs.set_env.outputs.app_root_directory }}
      # --- END FIX ---
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ env.BRANCH }}

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Install JQ for JSON parsing
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Install Trivy for re-validation
        run: |
          curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sudo sh -s -- -b /usr/local/bin
          trivy --version

      - name: Install npm (if needed for Node.js projects)
        run: |
          # Check if package.json exists in the specified APP_ROOT_DIR
          if [ -f "${{ env.APP_ROOT_DIR }}/package.json" ]; then
            echo "package.json detected. Installing npm."
            sudo apt-get install -y npm
            # npm config set unsafe-perm true # Potentially needed for global npm installs as root, depending on runner permissions
          else
            echo "package.json not detected in ${{ env.APP_ROOT_DIR }}. Skipping npm installation."
          fi

      # --- FIX: Uncomment and configure Go setup ---
      - name: Set up Go (if needed for Go projects)
        # Check if go.mod exists in the specified APP_ROOT_DIR
        if: ${{ runner.os == 'Linux' && format('{0}/go.mod', env.APP_ROOT_DIR) && github.repository_owner == github.repository_owner }} # Simplified check. Better check with 'if: -f go.mod' in shell, but this is a rough guard.
        uses: actions/setup-go@v5
        with:
          go-version: '1.x' # Use a specific version like '1.22' or '1.x' for latest
      # --- END FIX ---

      - name: Download Trivy report artifact
        uses: actions/download-artifact@v4
        with:
          name: trivy-security-report
          path: . # Downloads trivy-report.json to the current directory

      - name: Make remediation script executable
        run: chmod +x .github/scripts/reditest.py

      - name: Run remediation script
        id: run_remediation
        continue-on-error: true # Allow subsequent steps to run even if remediation fails
        run: |
          # The Python script will read its inputs from environment variables
          # as configured in the 'env:' block of this job.
          python .github/scripts/reditest.py
          
          # Capture the exit code of the python script
          if [ $? -eq 0 ]; then
            echo "remediation_status=success" >> $GITHUB_OUTPUT
          else
            echo "remediation_status=failure" >> $GITHUB_OUTPUT
          fi

      - name: Check for changes after remediation
        id: git_status
        run: |
          git add .
          # Check for changes in the working directory or staged area
          if ! git diff --quiet --exit-code || ! git diff --cached --quiet --exit-code; then
            echo "changes_made=true" >> $GITHUB_OUTPUT
            echo "Repository changes detected after remediation."
          else
            echo "changes_made=false" >> $GITHUB_OUTPUT
            echo "No changes detected after remediation."
          fi
          # Clean up staged changes if no commit is needed right away
          git restore --staged .

      - name: Commit & push fixes (if changes detected)
        if: steps.git_status.outputs.changes_made == 'true'
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "feat(security): Automated vulnerability remediation by Trivy report"
          branch: ${{ env.BRANCH }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Rebuild and Re-scan to Validate Fixes (if changes made)
        id: rebuild_and_rescan # Give this step an ID to reference its outputs
        if: steps.git_status.outputs.changes_made == 'true'
        run: |
          echo "Rebuilding and re-scanning image to validate fixes..."
          # Pull base image to ensure it's available for rebuild, as the runner might be clean
          docker pull "${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}" || echo "Warning: Could not pull original image, proceeding with build."

          # Build the remediated image with a new tag
          docker build -t "${{ env.IMAGE_NAME }}:remediated-${{ github.sha }}" \
            -f "${{ env.DOCKERFILE_PATH }}" \
            "${{ env.APP_ROOT_DIR }}"

          # Scan the newly built remediated image
          trivy image \
            --scanners vuln \
            --format json \
            --output trivy-remediated-report.json \
            "${{ env.IMAGE_NAME }}:remediated-${{ github.sha }}" || true # Continue on error if scan fails

          if [ -f trivy-remediated-report.json ] && jq -e '.[] | select(.Vulnerabilities != null and .Vulnerabilities | length > 0)' trivy-remediated-report.json > /dev/null; then
            echo "Vulnerabilities still present after remediation. Manual review needed."
            echo "remediation_validation=failure" >> $GITHUB_OUTPUT
          else
            echo "Image is clean after remediation. Great success!"
            echo "remediation_validation=success" >> $GITHUB_OUTPUT
          fi

      - name: Upload remediated report
        if: steps.git_status.outputs.changes_made == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: trivy-remediated-security-report
          path: trivy-remediated-report.json

      - name: Set remediation validation output
        id: set_remediation_validation_output
        # This output needs to be populated based on the previous step's output (Rebuild and Re-scan)
        if: steps.git_status.outputs.changes_made == 'true' # Only run if changes were made and validation occurred
        run: |
          echo "remediation_validation=${{ steps.rebuild_and_rescan.outputs.remediation_validation }}" >> $GITHUB_OUTPUT

      # - name: Notify Slack (Remediation Status)
      #   uses: rtCamp/action-slack-notify@v2
      #   env:
      #     SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK_URL }}
      #     SLACK_CHANNEL: '#devsecops-alerts'
      #     SLACK_USERNAME: 'Vulnerability Remediation Bot'
      #     SLACK_ICON_EMOJI: ':robot_face:'
      #     SLACK_MESSAGE: |
      #       *Automated Vulnerability Remediation Attempt Result*
      #       Repository: `${{ github.repository }}`
      #       Branch: `${{ env.BRANCH }}`
      #       Workflow Run: <https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}|#${{ github.run_id }}>
      #
      #       Status: ${{ steps.run_remediation.outputs.remediation_status }}
      #       ${{ steps.git_status.outputs.changes_made == 'true' && format('Validation Scan: {0}', steps.rebuild_and_rescan.outputs.remediation_validation) || 'No changes made by remediation.' }}
      #
      #       ${{ steps.git_status.outputs.changes_made == 'true' && 'Fixed files committed. New scan results attached as artifact.' || 'No fixes applied or no changes detected.' }}
      #       ${{ steps.run_remediation.outputs.remediation_status == 'failure' && 'ðŸš¨ Remediation failed or partial. Manual intervention required.' || '' }}
      #   if: always()

  # Uncomment and modify these deployment jobs as needed
  # ccli_hydra_e1_deployment:
  #   name: ðŸš€ðŸŸ¡ Deploy image to E1 Hydra
  #   needs: [set_env, docker_build_push, trivy_scan, remediation]
  #   if: needs.trivy_scan.outputs.vulnerabilities_found == 'false' || (needs.remediation.outputs.remediation_status == 'success' && needs.remediation.outputs.remediation_validation == 'success')
  #   uses: amex-eng/ace-platform-reusable-workflow/.github/workflows/deploy_to_hydra_ccli_validate.yml@main
  #   with:
  #     image_name_ccli: artifactory.aexp.com/dockerproxy/${{ needs.set_env.outputs.image_name }}
  #     sha256: ${{ needs.ace-build.outputs.pushed_image }}
  #     regions: US
  #     env: "E1"
  #     project: ${{ vars.PROJECT }}
  #     service: ${{ vars.SERVICE }}
  #     image_time_stamp: ${{ needs.set_env.outputs.image_tag }}
  #   secrets:
  #     SE_USERNAME: ${{ secrets.SE_USERNAME }}
  #     SE_PASSWORD: ${{ secrets.SE_PASSWORD }}
  #     ARTIFACTORY_USERNAME: ${{ secrets.ARTIFACTORY_USERNAME }}
  #     ARTIFACTORY_PASSWORD: ${{ secrets.ARTIFACTORY_PASSWORD }}
